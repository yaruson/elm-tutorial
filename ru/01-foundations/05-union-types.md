# Составные типы

Благодаря своей гибкости, __составные типы__ широко используются в Elm. В других языках они также называются алгебраическими типами данных. Простейший составной тип выглядит так:

```elm
type Answer = Yes | No
```

Тип `Answer` может принимать значения `Yes` и `No`.

## Тип и конструкторы

У составного типа есть следующие части:

```elm
type State = Pending | Done | Failed
    ^----^   ^---------------------^
     тип          конструкторы
```

В этом примере `State` является типом, а `Pending, Done и Failed` — конструкторами. Они называются конструкторами потому что при их использовании создаётся новый экземпляр данного типа, например:

```elm
pendingState = Pending
```

## Пример

Например, функция с таким определением:

```elm
respond : Answer -> String
```

В качестве первого аргумента может принимать `Yes` или `No`, то есть вызов `respond Yes` будет правильным.

```
respond : Answer -> String
respond answer =
    case answer of
      Yes ->
        ...
      No ->
        ...
```

## Нагрузка

Составные типы могут нести дополнительную информацию, связанную с ними:

```elm
type Answer = Yes | No | Other String
```

В этом примере, метка `Other` будет иметь ассоциированную строку. Вы можете вызвать `respond` так:

```elm
respond (Other "Hello")
```

Здесь скобки необходимы, иначе Elm интерпретирует запись как передачу двух аргументов в функцию `respond`.

## Использование в качестве функций

Обратите внимание на то, как мы добавили нагрузку к `Other`:

```elm
Other "Hello"
```

Это ни что иное как вызов функции `Other`. Составные типы ведут себя как обычные функции. Например, для типа:

```elm
type Answer = Message Int String
```

Создать экземпляр `Message` можно так:

```elm
Message 1 "Hello"
```

Кроме того, для составных типов, так же как и для обычных, можно делать частичное применение.

## Вкладывание

"Вкладывание" одного составного типа в другой является распространённой практикой.

```elm
type OtherAnswer = DontKnow | Perhaps | Undecided

type Answer = Yes | No | Other OtherAnswer
```

Теперь можно передать функции `respond` (которая ожидает `Answer`) следующее:

```elm
respond (Other Perhaps)
```

## Типы переменных

Кроме всего прочего, можно использовать переменные типов или дублёры:

```elm
type Answer a = Yes | No | Other a
```

Это `Answer`, который может использоваться с различными типами, например Int или String.

Предположим, функция `respond` выглядит так:

```elm
respond : Answer Int -> String
respond answer =
    ...
```

Используя `Answer Int` в определении функции, мы говорим что дублёр `a` должен быть типа `Int`.

Далее мы сможем вызвать respond так:

```elm
respond (Other 123)
```

Однако `respond (Other "Hello")` не сработает, потому что `respond` ожидает целое число в качестве `a`.

## Типовое применение

Одно из типовых применений составных типов — передача данных между функциями приложения, которые принимают на вход одно из множества возможных значений.

Например, в типичном веб-приложении, мы можем вырабатывать сообщения для произведения действий, например, загрузки списка пользователей, добавления, удаления и так далее. Некоторые из этих сообщений будут иметь нагрузку.

Обычной практикой является использование составных типов:

```elm
type Msg
    = LoadUsers
    | AddUser
    | EditUser UserId
    ...
```

## Некоторые распространённые составные типы

В Elm особенно часто встречаются несколько составных типов:

```
type Bool = True | False
```

В Elm нет булевого типа, это просто составной тип.

```
type Maybe a
    = Nothing
    | Just a
```

`Maybe` представляет возможность наличия или отсутствия чего либо.

```
type Result error value
    = Ok value
    | Err error
```

`Result` представляет вероятность одного из двух исходов операции: `Ok` с ассоциированным значением, и `Err` с ассоциированной ошибкой.

---

Про составные типы ещё есть много интересного. Вы можете узнать о них больше [здесь](http://elm-lang.org/guide/model-the-problem).
