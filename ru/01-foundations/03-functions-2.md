# Подробнее о функциях

## Переменные типа

Посмотрите на функцию со следующим определением:

```elm
indexOf : String -> List String -> Int
```

Эта гипотетическая функция принимает строку и список строк, и возвращает индекс, по которому данная строка была найдена в списке, либо -1, если не найдена.

Но что если нам придётся работать со списком целых чисел? Мы уже не сможем использовать эту функцию. Однако, мы можем сделать эту функцию __обобщённой__ с помощью __переменных типа__ или __дублёров__ вместо конкретных типов.

```elm
indexOf : a -> List a -> Int
```

После того как мы заменили `String` на `a`, определение функции теперь говорит, что `indexOf` принимает значение любого типа `a` и список такого же типа `a` и возвращает целое число. Покуда типы совпадают, компилятор не будет возражать. Вы можете вызывать `indexOf` со строкой и списком строк, либо целым числом и списком чисел, и всё будет работать.

Вот таким образом функции можно сделать более общими. Вы также можете использовать несоклько __переменных типов__:

```elm
switch : ( a, b ) -> ( b, a )
switch ( x, y ) =
  ( y, x )
```

Эта функция принимает кортеж из типов `a` и `b`, а возвращает кортеж из `b` и `a`. Все эти вызовы будут верными:

```elm
switch (1, 2)
switch ("A", 2)
switch (1, ["B"])
```

Стоит отметить, что для переменных типов можно использовать любой идентификатор в нижнем регистре, а `a` и `b` просто общепринятое обозначение. Например, следующее определение будет совершенно правильным:

```
indexOf : thing -> List thing -> Int
```

## Функции в качестве аргументов

Посмотрите на функцию со следующим определением:

```elm
map : (Int -> String) -> List Int -> List String
```

Эта функция:

- принимает функцию: часть `(Int -> String)`
- список целых чисел
- и возвращает список строк

Интересная часть — `(Int -> String)`. Она говорит, что передаваемая функция должна соответствовать определению `(Int -> String)`.

Например, `toString` из ядра является такой функцией. Таким образом, вы должны вызывать нашу функцию `map` так:

```elm
map toString [1, 2, 3]
```

Но типы `Int` и `String` слишком конкретные. Поэтому, большую часть времени вы будете иметь дело с определениями, использующими вместо них дублёры:

```elm
map : (a -> b) -> List a -> List b
```

Эта функция отображает список из `a` в список из `b`. Нам всё равно, какие типы представляют `a` и `b`, до тех пор, пока переданная первым аргументом функция использует такие же типы.

Например, если у нас есть такие функции:

```elm
convertStringToInt : String -> Int
convertIntToString : Int -> String
convertBoolToInt : Bool -> Int
```

Мы можем произвести обобщённое отображение следующим образом:

```elm
map convertStringToInt ["Hello", "1"]
map convertIntToString [1, 2]
map convertBoolToInt [True, False]
```
