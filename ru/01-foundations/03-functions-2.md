# Подробнее о функциях

## Переменные типа

Предположим, у нас есть функция, определённая как:

```elm
indexOf : String -> List String -> Int
```

Эта функция принимает искомую строку и список строк, а возвращает индекс строки в списке, если найдена, либо -1 если нет.

Но что будет, если нам придётся иметь дело со списком целочисленных значений? Эта функция уже не подойдёт. К счастью, мы можем превратить её в __обобщённую__ с помощью __переменных типа__ или __дублёров__ вместо конкретных типов.

```elm
indexOf : a -> List a -> Int
```

Когда мы заменили `String` на `a`, определение функции `indexOf` стало таким: функция принимает значение любого типа `a` и список значений того же типа `a`, а возвращает целое число. Теперь компилятор не будет возражать, покуда типы параметров совпадают. `indexOf` можно вызывать со строкой и списком строк, либо числом и списком чисел, и всё будет просто работать.

Вот таким образом функции можно сделать более общими. Вы также можете использовать несоклько __переменных типов__:

```elm
switch : ( a, b ) -> ( b, a )
switch ( x, y ) =
  ( y, x )
```

Эта функция принимает кортеж из типов `a` и `b`, а возвращает кортеж из `b` и `a`. Все эти вызовы будут верными:

```elm
switch (1, 2)
switch ("A", 2)
switch (1, ["B"])
```

Стоит отметить, что для переменных типов можно использовать любой идентификатор в нижнем регистре, `a` и `b` просто общепринятое обозначение. Например, такой идентификатор вполне имеет право на существование:

```
indexOf : thing -> List thing -> Int
```

## Функции в качестве аргументов

Посмотрите на следующее определение:

```elm
map : (Int -> String) -> List Int -> List String
```

Эта функция:

- принимает функцию `(Int -> String)`
- список целых чисел
- и возвращает список строк

Интересный момент — `(Int -> String)`, это говорит о том, что передаваемая функция должна соответствовать определению `(Int -> String)`.

Например, функция `toString` из стандарта языка подойдёт. С ней вы можете вызвать `map` так:

```elm
map toString [1, 2, 3]
```

Типы `Int` и `String` слишком конкретные. Как правило, большинство определений, которые вам встретятся, будут использовать дублёры:

```elm
map : (a -> b) -> List a -> List b
```

Эта функция отображает список из `a` в список из `b`. Нам без разницы, какие типы обозначаются `a` и `b`, пока аргументы переданной в начале функции имеет параметры соответствующего типа.

Например, имея на руках функции:

```elm
convertStringToInt : String -> Int
convertIntToString : Int -> String
convertBoolToInt : Bool -> Int
```

Мы можем произвести обобщённое отображение следующим образом:

```elm
map convertStringToInt ["Hello", "1"]
map convertIntToString [1, 2]
map convertBoolToInt [True, False]
```
