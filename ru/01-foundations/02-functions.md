# Основы функций

В этой главе мы познакомимся с основными элементами синтаксиса Elm: функциями, определениями функций, частичным применением и поточным оператором.

## Функции

Elm поддерживает два вида функций:

- анонимные
- именные

### Анонимные функции

Анонимные функции, как следует из названия, не имеют имени.

```elm
\x -> x + 1

\x y -> x + y
```

Между обратной косой чертой и стрелкой перечисляется список аргументов функции, а справа от стрелки — что делать с этими аргументами.

### Именные функции

Именные функции на Elm выглядят так:

```elm
add1 : Int -> Int
add1 x =
  x + 1
```

- Первая строка — это определение функции. Писать определения в Elm не обязательно, но желательно: так назначение функции становится более понятным.
- Всё остальное — реализация функции. Она должна соответствовать определению.

В этом примере определение говорит: "Функция принимает на вход целое число (Int) и возвращает другое целое".

Вызов функции выглядит так:

```
add1 3
```

Для вызова функции в Elm вместо скобок используется *пробел*.

Вот другая именная функция:

```elm
add : Int -> Int -> Int
add x y =
  x + y
```

Эта функция принимает два целочисленных аргумента (Int) и возвращает Int. Вызов будет такой:

```elm
add 2 3
```

### Функции без аргументов

Если функция в Elm не имеет аргументов, она будет являться константой:

```elm
name =
  "Sam"
```

### Как вызываются функции

Как было показано ранее, функция с двумя аргументами может выглядеть так:

```elm
divide : Float -> Float -> Float
divide x y =
    x / y
```

Сигнатуру можно понять так: "функция получает два числа с плавающей точкой и возвращает число с плавающей точкой".

```elm
divide 5 2 == 2.5
```

Однако, это будет не совсем верно. В Elm все функции принимают на вход только один аргумент. Результатом может быть другая функция.
Давайте разберёмся на примере:

```elm
-- Когда мы делаем вызов

divide 5 2

-- Он выполняется как:

((divide 5) 2)

-- Сначала выполняется `divide 5`.
-- Аргумент `5` применяется к `divide`, в результате получается промежуточная функция.

divide 5 -- -> промежуточная функция

-- Затем выполняется эта промежуточная функция `divide5`.
-- Если бы мы могли увидеть её определение и тело, то прочитали бы:

divide5 : Float -> Float
divide5 y =
  5 / y

-- Таким образом, мы получили функцию с уже применённой `5`.

-- Далее применяется следующий аргумент, то есть `2`:

divide5 2

-- После этого мы получаем конечный результат
```

Мы можем обходиться без скобок потому что применение функции **ассоциируется влево**.

### Группировка с помощью скобок

Если вы хотите использовать результат одной функции в вызове другой, необходимо использовать скобки для группировки вызовов:

```elm
add 1 (divide 12 3)
```

Здесь результат `divide 12 3` подаётся вторым параметром в `add`.

В противоположность, во многих других языках это может быть записано так:

```js
add(1, divide(12, 3))
```

## Частичное применение

Каждая функция принимает только один аргумент и возвращает либо другую функцию, либо конечный результат.
Это значит, что вы можете вызвать функцию вроде `add` с одним аргументом, например `add 2`, и получить *частично применённую функцию*.
Эта функция будет иметь определение `Int -> Int`.

`add 2` возвращает другую функцию с привязанной `2` в качестве первого параметра. Вызов промежуточной функции со вторым параметром вернёт `2 + ` второе значение:

```elm
add2 = add 2
add2 3 -- получится 5
```

Частичное применение крайне полезно для обеспечения читаемости кода и передачи состояния между функциями в приложении.

## Поточный оператор

Как было показано выше, вы можете делать вложенные вызовы так:

```elm
add 1 (multiply 2 3)
```

Это простой случай, но вот что происходит с более сложными:

```elm
sum (filter (isOver 100) (map getCost records))
```

Этот код сложно прочитать, потому что он выполняется наизнанку. Поточный оператор позволяет записывать такие выражения в читаемом виде:

```elm
3
    |> multiply 2
    |> add 1
```

Этот способ целиком опирается на частичное применение, рассмотренное ранее. В этом примере значение `3` передаётся к частично применённой функции `multiply 2`, а результат, в свою очередь — в частично применённую `add 1`.

С использованием поточного оператора трудночитаемый код из предыдущего примера можно переписать так:

```elm
records
    |> map getCost
    |> filter (isOver 100)
    |> sum
```
